from pokegan import Discriminator, Generator
from pokegan import batch_size, learning_rate, noise_size
from pokegan.data import PokemonImageDataset, ImageProcessor
import torchvision.transforms as transforms
from torch.utils.data import DataLoader
import torch.optim as optim
import torch.nn as nn
import torch, time, datetime, os


class GAN(object):
    def __init__(self, device=torch.device('cpu')):
        self.device = device
        self.generator = Generator().to(self.device)
        self.discriminator = Discriminator().to(self.device)

    def train(self, epochs=10):
        data_set = PokemonImageDataset(transform=transforms.Compose([
            ImageProcessor(),
            transforms.ToTensor()
        ]))
        data_loader = DataLoader(data_set, batch_size=batch_size, shuffle=True)

        real_label = 1
        fake_label = 0
        criterion = nn.BCELoss()
        optim_dis = optim.Adam(self.discriminator.parameters(), lr=learning_rate)
        optim_gen = optim.Adam(self.generator.parameters(), lr=learning_rate)
        start = time.time()

        for epoch in range(epochs):

            for data in data_loader:
                # train discriminator on real batch
                optim_dis.zero_grad()
                real_batch = data.to(self.device)
                label = torch.full((data.size(0),), real_label, device=self.device)
                output = self.discriminator(real_batch)
                dis_error_real = criterion(output, label)
                dis_error_real.backward()

                # train discriminator on fake batch generated by generator
                noise = torch.randn(data.size(0), noise_size, 1, 1, device=self.device)
                fake_batch = self.generator(noise)
                label.fill_(fake_label)
                output = self.discriminator(fake_batch.detach())
                dis_error_fake = criterion(output, label)
                dis_error_fake.backward()
                dis_error = dis_error_fake + dis_error_real
                optim_dis.step()

                # train generator
                optim_gen.zero_grad()
                label.fill_(real_label)
                output = self.discriminator(fake_batch)
                gen_error = criterion(output, label)
                gen_error.backward()
                optim_gen.step() 
            elapse = datetime.timedelta(seconds=(time.time() - start))
            print(f"epoch: {epoch}, time_elapsed: {elapse}, loss_d: {dis_error}, loss_g: {gen_error}")
        
    def save(self, path='./'):
        path = os.path.join(path, 'generator.pt')
        torch.save(self.generator.state_dict(), path)
